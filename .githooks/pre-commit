#!/usr/bin/env bash
# Prevent committing secrets or leaking API keys
set -e

# Get staged files
STAGED_FILES=$(git diff --cached --name-only)

# 1) Block committing secret config/account files outright
PROHIBITED=$(echo "$STAGED_FILES" | grep -E '(^config/secrets.*\.json$|^accounts\.json$)' || true)
if [ -n "$PROHIBITED" ]; then
  echo "[HOOK] ОТМЕНА коммита: нельзя коммитить секретные файлы:" >&2
  echo "$PROHIBITED" >&2
  exit 1
fi

# 2) Scan staged content for actual secret values (not just field names)
LEAKS=""
for f in $STAGED_FILES; do
  case "$f" in
    .githooks/*|config/secrets.example.json|accounts.json.example) continue;;
  esac
  content=$(git show ":$f" 2>/dev/null || true)
  # JSON-style explicit values like "GATEIO_API_KEY": "abcdef..."
  if echo "$content" | grep -Eiq '"GATEIO_API_(KEY|SECRET)"\s*:\s*"[^"]+"'; then
    # extract suspicious assignments excluding placeholders
    suspicious=$(echo "$content" | grep -Ein '"GATEIO_API_(KEY|SECRET)"\s*:\s*"(?!YOUR|your|PLACEHOLDER|\*\*\*|example|test)[^"]{16,}"' || true)
    if [ -n "$suspicious" ]; then
      LEAKS="$LEAKS\n$f: содержит явные значения GATEIO_API_KEY/SECRET"
    fi
  fi
  # Heuristic: 32+ hex near key/secret words (including Russian "ключ")
  if echo "$content" | grep -Eiq '((key|secret|ключ)[^\n]{0,40}[A-Fa-f0-9]{32,})|([A-Fa-f0-9]{32,}[^\n]{0,40}(key|secret|ключ))'; then
    LEAKS="$LEAKS\n$f: похожие на ключи hex-токены"
  fi
done

if [ -n "$LEAKS" ]; then
  echo "[HOOK] ОТМЕНА коммита: обнаружены возможные секреты:" >&2
  echo -e "$LEAKS" >&2
  echo "Подсказка: уберите реальные ключи, используйте placeholders или исключите файл." >&2
  exit 1
fi

exit 0
