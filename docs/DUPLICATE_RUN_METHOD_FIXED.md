# Исправление дублирующегося метода _run()

**Дата**: 2025
**Файл**: `autotrader.py`

## Обнаруженная проблема

В файле `autotrader.py` был обнаружен **критический баг в структуре кода**:

1. **Метод `_run()` был определён дважды**:
   - Первый раз на строке ~1975 (корректный, простой цикл)
   - Второй раз на строке ~2050 (сложный, с обработкой `changed_bases`)

2. **Второй метод `_run()` был вложен внутри другого метода**:
   - Он находился внутри метода `_determine_active_step_by_cumulative_drop()`
   - Это приводило к некорректной структуре кода

## Последствия бага

### Возможные причины множественных стартовых покупок:

1. **Два метода `_run()` конкурировали** за обработку циклов торговли
2. Второй метод (вложенный) **содержал собственный бесконечный цикл `while self.running:`**
3. Это могло приводить к **одновременной обработке одной и той же валюты** обоими методами
4. **Конкуренция за доступ к `self.cycles`** без блокировок

### Почему это вызывало множественные стартовые покупки:

- Оба метода вызывали `_try_start_cycle()` для одной и той же валюты
- Проверка баланса BASE выполнялась **до покупки**, а не после
- Между проверкой и покупкой другой поток успевал:
  1. Проверить баланс (ещё мало)
  2. Начать свою покупку
- В итоге **два параллельных ордера на стартовую покупку**

## Решение

### Что сделано:

1. **Удалён второй (вложенный) метод `_run()`** из метода `_determine_active_step_by_cumulative_drop()`

2. **Исправлен метод `_determine_active_step_by_cumulative_drop()`**:
   ```python
   def _determine_active_step_by_cumulative_drop(self, base: str, current_price: float) -> int:
       """Определяет активный шаг на основе кумулятивного падения цены."""
       # Теперь просто вычисляет и возвращает номер шага
       # Без бесконечного цикла!
   ```

3. **Оставлен только один метод `_run()`** (простой вариант на строке ~1975):
   ```python
   def _run(self):
       while self.running:
           # Простая обработка всех разрешённых валют
           for base in perms:
               self._try_start_cycle(base, quote)
               self._try_rebuy(base, quote)
           time.sleep(self._sleep_interval)
   ```

### Почему это должно решить проблему:

✅ **Теперь только ОДИН поток обработки** - запускается методом `start()` (строка 246)  
✅ **Нет конкуренции** между двумя методами `_run()`  
✅ **Последовательная обработка** всех валют в едином цикле  
✅ **Проще отслеживать** выполнение логики  

## Дополнительные защиты

В коде уже есть:

1. **Проверка баланса BASE** перед стартом:
   ```python
   base_balance_in_quote < purchase_usd  # строка 0 таблицы
   ```

2. **Проверка `active` флага**:
   ```python
   if cycle.get('active'):
       return  # Цикл уже активен
   ```

3. **Диагностика** для отслеживания причин старта/отказа

## Тестирование

### Что проверить:

1. ✅ Компиляция кода - **ошибок нет**
2. ⏳ Запустить автотрейдер и проверить:
   - Множественные стартовые покупки больше НЕ происходят
   - Ребай работает корректно (только при достижении кумулятивного падения)
   - Продажа работает корректно

### Ожидаемое поведение:

- **Один поток** обрабатывает все валюты последовательно
- **Один цикл** на валюту в любой момент времени
- **Одна стартовая покупка** за раз

## Файлы

- **Исправлен**: `autotrader.py`
- **Документация**: `DUPLICATE_RUN_METHOD_FIXED.md` (этот файл)

## Примечание

Если множественные стартовые покупки всё ещё происходят после этого исправления, возможные причины:

1. Внешние вызовы метода `_try_start_cycle()` из других мест
2. Проблемы с сохранением состояния `self.cycles` в файл/из файла
3. Необходимость добавления блокировок (locks) для атомарности операций

В этом случае потребуется дополнительная диагностика и защита через `threading.Lock`.
